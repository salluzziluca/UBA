# 1. Abstract Factory
> Proporciona una interfaz para crear familias de objetos relacionados o que dependen entre sí, sin especificar sus clases concretas

Este patrón se usa cuando tenemos varias clases diferentes, pero relacionadas que pueden tener 2 o más variantes de ellas mismas. Para esto abstraemos esas clases utilizando interfaces y luego abstraemos una fábrica que devuelve esas interfaces. De esa forma, podemos crear fábricas que devuelvan una variante concreta de esas clases.
![[Pasted image 20221016172250.png]]
Un ejemplo concreto seria con botones de una web page. tenemos el boton de inicio y el de busqueda y necesitamos que sean de x forma y color para windows y de x forma y color para mac.

# 2. Builder
> Separa la construcción de un objeto complejo de su representación, de forma que el mismo proceso de construcción pueda crear diferentes representaciones.

En vez de tener un constructor que sea `Casa(true, true, false, true, true, true)`. Utilizamos una interfaz builder, la cual tiene diferentes parámetros correspondientes a las diferentes características de la clase que estemos construyendo. 
```java
car.setSeat(int)
car.serEngine(Engine)
```
Adicionalmente, podemos tener un director el cual se encarga de gestionar las construcciones y nos puede ayudar a construir versiones ya definidas de la clase. 
![[Pasted image 20221016175712.png]]Ejemplo de un director concreto
![[example-en 1.png]]
# 3. Factory Method
> Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qué clase instanciar. Permite que una clase delegue en sus subclases la creación de objetos.

Es util cuando tenemos dos clases que hacen lo mismo con sus variaciones en comportamientos internos (Entrega de pedidos en bici, en moto y en helicóptero). De esa forma, mientras ambos productos cumplan con la interfaz correspondiente, la clase `Creador` puede crearlos a cualquiera de los dos. No tenes atado todo a una clase particular y toda al logica que decide cual de las variantes del objeto elegir está dentro del creador.

![[Pasted image 20221016181646.png]]

# Prototype 
>Especifica los tipos de objetos a crear por medio de una instancia prototípica, y crea nuevos objetos copiando de este prototipo.

Todo aquel objeto que pueda ser clonado implementa la interfaz prototype, y ahi se especifica su clonacion. Esto permite acceder a los campos privados tambien y realizar una clonacion exitosa

![[Pasted image 20221016183403.png]]

# Singleton
>Garantiza que una clase sólo tenga una instancia, y proporciona un punto de acceso global a ella.

Se trata de reutilizar la misma instancia cada vez que se la llama
![[Pasted image 20221017195433.png]]

# Adapter
>Convierte la interfaz de una clase en otra distinta que es la que esperan los clientes. Permite que cooperen clases que de otra manera no podrían por tener interfaces incompatibles.

Es un PUTISIMO ADAPTADOR, no hay mas magia. Clase 1 habla español Clase 2 habla ingles el adapter adapta de español a ingles, LISTOOO.
![[Pasted image 20221017195645.png]]

# Bridge
>Desacopla una abstracción de su implementación, de manera que ambas puedan variar de forma independiente.

Permite dividir una clase grande en dos partes de la misma (abstracción e implementación), para que puedan laburar una independientemente de la otra.
La abstracción delega a la implementación, siempre.
Este patron permite escalar ambas partes tranquilamente sin tener que laburar de manera monolitica.
![[Pasted image 20221017200342.png]]
# Composite
>Combina objetos en estructuras de árbol para representar jerarquías de parte-todo. Permite que los clientes traten de manera uniforme a los objetos individuales y a los compuestos.

==Solo tiene sentido si el modelo central del programa puede representarse en forma de [[Arboles|arbol]]== 
Si vos necesitas ejecutar una accion que involucre la totalidad de varios elementos que esten nesteados, simplemente se lo pedis al primero y haces que este se lo pida a sus hijos, y estos a sus hijos, y asi [[Algoritmos Recursivos|recursivamente]]
![[Pasted image 20221017201559.png]]
El Composite siempre delega el trabajo a sus componentes hijos.

# Decorador
>Añade dinámicamente nuevas
responsabilidades a un objeto,
proporcionando una alternativa
flexible a la herencia para
extender la funcionalidad.